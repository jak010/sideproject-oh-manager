# Oh Manager

- Author: jako
- WriteBy : Gemini + ChatGpt

## 1. 프로젝트 개요

"Oh Manager"는 흩어져 있는 오디션 정보를 하나로 모으고, 사용자에게 정말 필요한 정보만 자연스럽게 흘러가도록 설계한 백엔드 프로젝트다. 단순히 데이터를 가져오고 보여주는 시스템을 넘어서, **정보의 흐름
**과 **사용자의 액션**이 끊김 없이 이어지도록 만드는 데 집중했다.

이 서비스는 크게 두 컴포넌트로 나뉜다.

1. **`oh-manager-api`** — 사용자 인증, 회원/프로필 관리, 오디션 조회·지원 등 클라이언트와 직접 맞닿는 API 서버. FastAPI 기반이며, 클린 아키텍처와 DDD를 기반으로 구조적 확장성을
   확보했다.
2. **`oh-manager-scheduler`** — 외부 오디션 정보를 주기적으로 수집·정제하는 백그라운드 서비스. 독립적으로 구동되며 APScheduler로 일정한 간격의 작업을 자동 수행한다.

이 프로젝트는 “잘 돌아가는 시스템”이 아니라, **변화에 강하고 개발자가 건드리기 편한 시스템**을 목표로 설계하고 구현했다.

---

## 2. 문제 정의 — 왜 시작했는가?

오디션 정보는 대부분 여러 플랫폼에 흩어져 있고, 각 플랫폼은 모두 제각각의 규칙과 포맷으로 운영된다. 사용자는 원하는 정보를 찾기 위해 여러 앱과 웹사이트를 왔다 갔다 해야 한다. 고민의 출발점은 단순했다.

> “오디션 정보를 한눈에 보고, 정리하고, 지원까지 매끄럽게 할 순 없을까?”

내가 해결하고 싶었던 문제는 다음 네 가지였다.

* **정보 접근성** — 흩어진 데이터를 하나의 엔드포인트로 통합
* **개인화 추천** — 사용자의 관심사 기반으로 오디션을 정제해 제공
* **지원 관리의 효율화** — 지원한 오디션의 상태를 추적하고 정리
* **안정성과 확장성** — 많은 데이터, 많은 요청에도 안정적으로 버티는 API

---

## 3. 내 역할과 책임

전체적인 백엔드 구조를 설계하고, 핵심 도메인·유스케이스·트랜잭션 관리·DI·보안 로직 전반을 구현했다. 단순 기능 구현이 아니라 **구조를 설계하고 시스템의 원칙을 만드는 역할**에 가깝다.

아래는 실제 코드 기준으로 내가 맡은 부분들이다.

### ✦ 아키텍처와 프레임워크 선택

* FastAPI 기반의 클린 아키텍처 도입
* `application.py`, `settings/base.py`에서 전체 구조 골격 설계

### ✦ 의존성 주입 구조 설계

* `dependency_injector`로 DB, Repository, AWS 의존성 컨테이너 구성
* `patch_ioc`를 통해 서비스 레이어 전체에 injection 적용

### ✦ 트랜잭션 관리 체계화

* 요청 단위로 일관된 트랜잭션을 보장하는 `TransactionRoute` 직접 구현
* 롤백·커밋 제어를 라우터 단에서 통합해 도메인 코드의 순수성 확보

### ✦ 도메인 모델링 전체 설계

* `dataclasses` 기반 엔티티 구조화 (`MemberEntity`, `SessionEntity`, `VerificationEntity` 등)
* 서비스 레이어에서 비즈니스 규칙을 캡슐화 (`MemberService`, `SessionService` 등)

### ✦ 유스케이스 계층 구현

* 회원가입, 인증, 세션 생성, 토큰 검증 등 핵심 흐름 정의하는 유스케이스 직접 작성

### ✦ 영속성 계층 및 ORM 매핑

* SQLAlchemy ORM 매핑 설계 (`adapter/database/orm.py`)

### ✦ 인증·보안 구현

* bcrypt 기반 해싱
* JWT 인증 흐름 전체 구현 (생성, 검증, 세션 관리)

### ✦ 스케줄러 서비스 설계

* `oh-manager-scheduler` 전체 구조 설계 및 크론 작업 흐름 구축

---

## 4. 기술적 의사결정과 그 이유

내가 개발에서 가장 신경 쓰는 부분은 **“왜 이 기술을 썼는가?”**와 **“이 구조로 갔을 때 유지보수는 얼마나 편해지는가?”**이다.

아래는 실제 고민과 기술 선택의 기준들이다.

### ● FastAPI 선택 이유

* 빠른 개발 사이클
* 타입 힌트 기반으로 가독성·IDE 활용도 극대화
* 비동기 지원으로 고성능 API 구성 가능

### ● 구조 설계 기준 — Clean + DDD

* 계층 간 책임을 확실히 분리
* 컨트롤러는 오로지 HTTP, 비즈니스는 유스케이스, 규칙은 도메인에서 처리
* DIP 적용해 테스트 용이성 확보

### ● 데이터 모델링 기준

* `dataclasses`로 엔티티를 단순·명확하게 정의
* 팩토리 메서드로 일관된 생성 패턴 유지
* Enum 기반 상태 모델링으로 오타 방지 및 의도 명확화

### ● 비동기 처리 / 캐싱 / 성능 고려

* FastAPI async 기반 처리로 I/O 대기 최소화
* JWT 무상태 인증 + 짧은 만료 시간 전략
* `cached_property`로 반복 조회 비용 절감
* 스케줄러로 API 서버의 부담을 분리

### ● 보안·예외 처리 전략

* 계층별 에러 전략 분리
* 비즈니스 예외는 유스케이스에서, HTTP 변환은 컨트롤러에서
* 트랜잭션 라우터로 예외 발생 시 자동 롤백

---

## 5. 구현 과정 핵심 흐름

단순히 “기능을 만들었다”가 아니라, **흐름을 어떻게 설계했는가**에 초점을 맞춘다.

### ✦ 회원가입 요청 → 인증 → 로그인이라는 기본 플로우

각 단계가 서로 독립적으로 보이지만, 도메인 규칙 기반으로 조밀하게 연결되어 있다.

1. **회원가입 요청**

    * 이메일 검증 → 중복 확인 → 비밀번호 해싱
    * `DEACTIVE` 상태 회원 생성
    * 인증 엔티티 발급

2. **인증 코드 검증**

    * 만료·상태 확인
    * 활성화 전환 + 기본 프로필 생성
    * 개인 저장 공간(S3 등) 준비

3. **로그인**

    * 비밀번호 검증 → 상태 검증 → 세션 생성
    * JWT 발급 후 반환

4. **JWT 인증 미들웨어**

    * 토큰 검증 → 세션 조회 → 만료 여부 검증

---

## 6. 문제 해결 경험 & 트러블슈팅

### ● 이메일 전송 기능이 실제로 구현되지 않은 문제

코드에는 다음과 같은 주석이 있다.

> `TODO: Email 전송 코드 구현 필요함`

초기엔 더미로 남겨두었지만, 실제 서비스 단계에서는 반드시 해결해야 하는 문제였다.

#### 내가 고민한 개선 방향

* SendGrid / AWS SES 등의 외부 서비스 연동 고려
* 이메일 전송은 API 응답을 지연시키므로 반드시 **비동기 태스크 큐로 분리**
* Celery 등으로 재시도 로직을 포함한 안정적 전송 구조 구축

### ● 트랜잭션 관리 복잡성 해결

초기는 각 유스케이스에서 세션을 직접 관리하려 했지만, 이는 실수와 중복을 부르는 구조였다.

**해결:**

* `TransactionRoute`를 만들어 트랜잭션을 라우터 단에서 자동 관리
* 비즈니스 로직은 "순수한 도메인 규칙"에만 집중 가능해짐

이 구조 이후 코드의 안정성과 예측 가능성이 크게 올라갔다.

---
